import { NextResponse } from 'next/server'
import { createServiceClient } from '@/lib/supabase/server'
import { publishScheduledPosts } from '@/lib/pipeline/publisher'
import { selectNextTopic } from '@/lib/autopilot/topicSelector'
import { generateContent } from '@/lib/ai/generator'
import { publishToX } from '@/lib/platforms/x'
import { publishToTelegram } from '@/lib/platforms/telegram'
import { publishToLinkedIn } from '@/lib/platforms/linkedin'
import { createPlatformVariants } from '@/lib/platforms/transformers'
import { checkTimeMatch, logPipeline, extractRecentTopics, shouldGenerateImageForTime, getPlatformsForTime, type ScheduleConfig } from '@/lib/autopilot/workflow-helpers'
import { generateImageWithStability } from '@/lib/ai/providers/stability-image'
import { uploadImageToStorage } from '@/lib/storage/image-upload'
import type { PublishArgs } from '@/lib/pipeline/types'
import type { Database } from '@/types/database'

export const runtime = 'nodejs'
export const maxDuration = 60

// Types derived from Database for type safety
type PostInsert = Database['public']['Tables']['posts']['Insert']
type WorkflowRunInsert = Database['public']['Tables']['workflow_runs']['Insert']
type Platform = Database['public']['Tables']['posts']['Row']['platform']
type PostStatus = Database['public']['Tables']['posts']['Row']['status']
type WorkflowStatus = Database['public']['Tables']['workflow_runs']['Row']['status']

// Types for database queries
type UserProfile = {
  id: string
  topics: string[] | null
  tone: string | null
  autopilot_enabled: boolean | null
}

type ConnectedAccount = {
  id: string
  platform: Platform
  access_token: string
  platform_user_id: string
  username: string
  token_expires_at: string | null
}

type RecentPost = {
  topic: string | null
  content: string
}

/**
 * Cron Publish Endpoint (Enhanced)
 * 
 * Phase 1: Publishes all scheduled posts that are due (existing functionality)
 * Phase 2: If no scheduled posts, auto-generates content for autopilot users (new functionality)
 * 
 * Safe to call repeatedly (idempotent) - uses row locking and workflow_runs to prevent duplicates.
 * 
 * Can be triggered by:
 * - Supabase Cron (every 5 minutes)
 * - Manual trigger
 * - External monitoring services
 * 
 * No authentication required for cron endpoint
 */
export async function GET() {
  console.log('=== CRON PUBLISH STARTED ===')
  console.log('Timestamp:', new Date().toISOString())
  
  try {
    // PHASE 1: Publish scheduled posts (existing functionality)
    console.log('\n[Phase 1] Publishing scheduled posts...')
    const scheduledResult = await publishScheduledPosts()
    
    console.log(`[Phase 1] Completed: ${scheduledResult.published} published, ${scheduledResult.failed} failed`)
    
    // PHASE 2: Auto-generate if no scheduled posts were published (new functionality)
    let autoGenResult = null
    
    if (scheduledResult.published === 0) {
      console.log('\n[Phase 2] No scheduled posts found. Checking for autopilot users...')
      autoGenResult = await autoGenerateAndPublish()
    } else {
      console.log('\n[Phase 2] Skipped (scheduled posts were published)')
    }
    
    console.log('\n=== CRON PUBLISH COMPLETED ===')
    
    return NextResponse.json({
      success: true,
      scheduled: {
        published: scheduledResult.published,
        failed: scheduledResult.failed,
        errors: scheduledResult.errors,
      },
      autoGenerated: autoGenResult,
      timestamp: new Date().toISOString(),
    })
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    
    console.error('[Cron Publish] Fatal error:', errorMessage)
    
    return NextResponse.json({
      success: false,
      error: errorMessage,
      timestamp: new Date().toISOString(),
    }, { status: 500 })
  }
}

/**
 * POST endpoint for manual triggering
 */
export async function POST() {
  return GET() // Same logic, just allows POST requests too
}

/**
 * Auto-generate and publish content for autopilot users
 * 
 * This function:
 * 1. Gets all users with autopilot enabled
 * 2. Checks if current time matches their schedule
 * 3. Verifies no duplicate execution (via workflow_runs table)
 * 4. Generates content using Claude API
 * 5. Publishes to X and Telegram immediately
 * 6. Records workflow run for idempotency
 */
async function autoGenerateAndPublish(): Promise<{
  processed: number
  results: Array<{ userId: string; status: string; error?: string; timeSlot?: string }>
}> {
  const supabase = createServiceClient()
  const results: Array<{ userId: string; status: string; error?: string; timeSlot?: string }> = []
  
  try {
    // Step 1: Get all users with autopilot enabled
    const { data: users, error: usersError } = await supabase
      .from('user_profiles')
      .select('id, topics, tone, autopilot_enabled')
      .eq('autopilot_enabled', true)
    
    if (usersError) {
      console.error('[Auto-Gen] Failed to fetch users:', usersError)
      return { processed: 0, results: [] }
    }
    
    if (!users || users.length === 0) {
      console.log('[Auto-Gen] No users with autopilot enabled')
      return { processed: 0, results: [] }
    }
    
    console.log(`[Auto-Gen] Found ${users.length} user(s) with autopilot enabled`)
    
    // Step 2: Process each user
    for (const user of users as UserProfile[]) {
      console.log(`\n[Auto-Gen] Processing user: ${user.id}`)
      
      try {
        // Get user's schedule configuration (including platform_preferences)
        const { data: scheduleData } = await supabase
          .from('schedule_config')
          .select('days_of_week, times, timezone, image_generation_enabled, image_times, platform_preferences')
          .eq('user_id', user.id)
          .single()
        
        const schedule = scheduleData as ScheduleConfig | null
        
        if (!schedule || !schedule.times || schedule.times.length === 0) {
          console.log('[Auto-Gen] No schedule configured for user')
          await logPipeline(supabase, user.id, 'planning', 'warning', 'No schedule configured')
          results.push({ userId: user.id, status: 'skipped', error: 'No schedule configured' })
          continue
        }
        
        // Check if current time matches schedule
        const matchResult = checkTimeMatch(schedule)
        
        if (!matchResult.matches) {
          console.log(`[Auto-Gen] Not time to post. Current: ${matchResult.currentTime}, Schedule: ${schedule.times.join(', ')}`)
          results.push({ userId: user.id, status: 'skipped', error: 'Not time to post' })
          continue
        }
        
        console.log(`[Auto-Gen] ✓ Time matches schedule: ${matchResult.matchedTime}`)
        
        // Check for duplicate execution (idempotency)
        const timeSlot = matchResult.timeSlot
        const { data: existingRun } = await supabase
          .from('workflow_runs')
          .select('id')
          .eq('user_id', user.id)
          .eq('time_slot', timeSlot)
          .single()
        
        if (existingRun) {
          console.log(`[Auto-Gen] Already executed for time slot: ${timeSlot}`)
          results.push({ userId: user.id, status: 'skipped', error: 'Already executed', timeSlot })
          continue
        }
        
        console.log(`[Auto-Gen] ✓ No duplicate found for time slot: ${timeSlot}`)
        
        // Get platforms to post to for this time slot (DYNAMIC SELECTION)
        const platformsToPost = getPlatformsForTime(schedule, matchResult.matchedTime)
        
        if (platformsToPost.length === 0) {
          console.log('[Auto-Gen] No platforms configured for this time slot')
          results.push({ userId: user.id, status: 'skipped', error: 'No platforms configured' })
          continue
        }
        
        console.log(`[Auto-Gen] Platforms for ${matchResult.matchedTime}:`, platformsToPost)
        
        // Get connected accounts for selected platforms only
        const { data: accountsData } = await supabase
          .from('connected_accounts')
          .select('id, platform, access_token, platform_user_id, username, token_expires_at')
          .eq('user_id', user.id)
          .eq('is_active', true)
          .in('platform', platformsToPost)
        
        const accounts = accountsData as ConnectedAccount[] | null
        
        if (!accounts || accounts.length === 0) {
          console.log(`[Auto-Gen] No active accounts for platforms: ${platformsToPost.join(', ')}`)
          await logPipeline(supabase, user.id, 'publishing', 'warning', 'No active accounts for selected platforms')
          results.push({ userId: user.id, status: 'skipped', error: 'No accounts connected for selected platforms' })
          continue
        }
        
        // Get recent posts to avoid repetition
        const { data: recentPostsData } = await supabase
          .from('posts')
          .select('topic, content')
          .eq('user_id', user.id)
          .order('created_at', { ascending: false })
          .limit(10)
        
        const recentPosts = recentPostsData as RecentPost[] | null
        const recentTopics = extractRecentTopics(recentPosts || [])
        const recentContents = (recentPosts || []).map(p => p.content)
        
        // Select topic
        const { topic, reason } = await selectNextTopic(user.topics || [], recentTopics)
        console.log(`[Auto-Gen] Selected topic: "${topic}" - ${reason}`)
        
        await logPipeline(supabase, user.id, 'planning', 'success', `Topic selected: ${topic}`, { topic, reason })
        
        // Check if we should generate an image for this time slot
        const shouldGenerateImage = shouldGenerateImageForTime(schedule, matchResult.matchedTime)
        console.log(`[Auto-Gen] Image generation: ${shouldGenerateImage ? 'ENABLED' : 'DISABLED'} for time ${matchResult.matchedTime}`)
        
        // Generate content with Claude (and image prompt if needed)
        console.log('[Auto-Gen] Generating content with Claude...')
        const result = await generateContent(user.id, {
          topic,
          tone: user.tone || 'professional',
          recentPosts: recentContents,
          generateImagePrompt: shouldGenerateImage,
        })
        
        const masterContent = result.content
        const prompt = result.prompt
        const model = result.model
        let imagePrompt = result.imagePrompt
        
        console.log(`[Auto-Gen] ✓ Content generated (${masterContent.length} chars)`)
        if (imagePrompt) {
          console.log(`[Auto-Gen] ✓ Image prompt generated (${imagePrompt.length} chars)`)
        }
        await logPipeline(supabase, user.id, 'generation', 'success', 'Content generated', {
          model,
          contentLength: masterContent.length,
          hasImagePrompt: !!imagePrompt
        })
        
        // IMAGE GENERATION WORKFLOW
        let imageData: string | undefined
        let imageUrl: string | undefined
        
        if (shouldGenerateImage && imagePrompt) {
          console.log('[Auto-Gen] Image generation REQUIRED for this time slot')
          
          const stabilityApiKey = process.env.STABILITY_API_KEY
          
          if (!stabilityApiKey) {
            console.error('[Auto-Gen] STABILITY_API_KEY not configured')
            await logPipeline(supabase, user.id, 'generation', 'error',
              'Image generation failed: STABILITY_API_KEY not configured')
          } else {
            try {
              console.log('[Auto-Gen] Generating image with Stability AI...')
              
              const stabilityResult = await generateImageWithStability({
                prompt: imagePrompt,
                apiKey: stabilityApiKey,
              })
              
              if (stabilityResult.success && stabilityResult.base64Data) {
                imageData = stabilityResult.base64Data
                console.log('[Auto-Gen] ✓ Image generated!')
                console.log('[Auto-Gen] Uploading to Supabase Storage...')
                
                const uploadResult = await uploadImageToStorage(
                  stabilityResult.base64Data,
                  user.id
                )
                
                if (uploadResult.success && uploadResult.publicUrl) {
                  imageUrl = uploadResult.publicUrl
                  console.log('[Auto-Gen] ✓ Image uploaded! URL:', imageUrl)
                  console.log('[Auto-Gen] ✓ Image will be stored in database with posts')
                  
                  await logPipeline(supabase, user.id, 'generation', 'success',
                    'Image pipeline successful', {
                      imagePrompt: imagePrompt.substring(0, 200),
                      imageUrl,
                      imageStoragePath: uploadResult.publicUrl,
                      hasImageData: true
                    })
                } else {
                  console.error('[Auto-Gen] Image upload failed:', uploadResult.error)
                  await logPipeline(supabase, user.id, 'generation', 'warning',
                    `Image upload failed: ${uploadResult.error}`)
                }
              } else {
                console.error('[Auto-Gen] Stability AI failed:', stabilityResult.error)
                await logPipeline(supabase, user.id, 'generation', 'warning',
                  `Stability AI failed: ${stabilityResult.error}`)
              }
            } catch (imageError) {
              console.error('[Auto-Gen] Image pipeline error:', imageError)
              await logPipeline(supabase, user.id, 'generation', 'error',
                `Image error: ${imageError instanceof Error ? imageError.message : 'Unknown'}`)
            }
          }
        } else if (shouldGenerateImage && !imagePrompt) {
          console.log('[Auto-Gen] Image enabled but no prompt created')
        } else {
          console.log('[Auto-Gen] Image generation NOT required for this time slot')
        }
        
        // Create platform variants
        const variants = createPlatformVariants(masterContent)
        
        // Publish to each platform immediately
        const platformsPublished: string[] = []
        
        for (const account of accounts) {
          const platform = account.platform
          
          // Select appropriate content variant for platform
          let content: string
          switch (platform) {
            case 'x':
              content = variants.x
              break
            case 'telegram':
              content = variants.telegram
              break
            case 'linkedin':
              content = variants.linkedin
              break
            default:
              console.warn(`[Auto-Gen] Unknown platform: ${platform}`)
              continue
          }
          
          console.log(`[Auto-Gen] Publishing to ${platform} (${account.username})...`)
          
          try {
            // Prepare media URLs if image was generated
            const mediaUrls: string[] = []
            if (imageUrl) {
              mediaUrls.push(imageUrl)
              console.log(`[Auto-Gen] Including image in post: ${imageUrl}`)
            }
            
            const publishArgs: PublishArgs = {
              accessToken: account.access_token,
              platformUserId: account.platform_user_id || account.username,
              content,
              mediaUrls: mediaUrls.length > 0 ? mediaUrls : undefined,
              tokenExpiresAt: account.token_expires_at || null,
            }
            
            console.log(`[Auto-Gen] Publishing with ${mediaUrls.length} media attachment(s)`)
            
            let publishResult
            
            if (platform === 'x') {
              publishResult = await publishToX(publishArgs)
            } else if (platform === 'telegram') {
              publishResult = await publishToTelegram({
                ...publishArgs,
                platformUserId: account.platform_user_id,
              })
            } else if (platform === 'linkedin') {
              publishResult = await publishToLinkedIn(publishArgs)
            } else {
              continue // Skip unsupported platforms
            }
            
            if (!publishResult.success) {
              throw new Error(publishResult.error || 'Unknown error')
            }
            
            // Save published post record
            const publishedPost: PostInsert = {
              user_id: user.id,
              account_id: account.id,
              status: 'published' satisfies PostStatus,
              content,
              platform,
              published_at: new Date().toISOString(),
              platform_post_id: publishResult.postId,
              generation_prompt: prompt,
              generation_model: model,
              generation_metadata: {
                master_content: masterContent,
                image_prompt: imagePrompt || null,
                image_generation_enabled: shouldGenerateImage,
                has_image: !!(imageData || imageUrl)
              },
              image_url: imageUrl || null,
              image_data: imageData || null,
              topic,
            }
            await supabase.from('posts').insert(publishedPost)
            
            console.log(`[Auto-Gen] ✓ Published to ${platform} (ID: ${publishResult.postId})`)
            await logPipeline(supabase, user.id, 'publishing', 'success', `Published to ${platform}`, {
              platform,
              postId: publishResult.postId,
            })
            
            platformsPublished.push(platform)
            
          } catch (publishError) {
            console.error(`[Auto-Gen] Failed to publish to ${platform}:`, publishError)
            await logPipeline(supabase, user.id, 'publishing', 'error', 
              `Failed to publish to ${platform}: ${publishError instanceof Error ? publishError.message : 'Unknown'}`)
            
            // Save failed post record
            const failedPost: PostInsert = {
              user_id: user.id,
              account_id: account.id,
              status: 'failed' satisfies PostStatus,
              content,
              platform,
              generation_prompt: prompt,
              generation_model: model,
              generation_metadata: {
                master_content: masterContent,
                image_prompt: imagePrompt || null,
                image_generation_enabled: shouldGenerateImage,
                has_image: !!(imageData || imageUrl)
              },
              image_url: imageUrl || null,
              image_data: imageData || null,
              topic,
            }
            await supabase.from('posts').insert(failedPost)
          }
        }
        
        // Record workflow run (for idempotency)
        const runStatus: WorkflowStatus = platformsPublished.length > 0 ? 'completed' : 'failed'
        const workflowRun: WorkflowRunInsert = {
          user_id: user.id,
          time_slot: timeSlot,
          status: runStatus,
          platforms_published: platformsPublished,
        }
        await supabase.from('workflow_runs').insert(workflowRun)
        
        results.push({
          userId: user.id,
          status: runStatus,
          timeSlot,
        })
        
      } catch (userError) {
        console.error(`[Auto-Gen] Error processing user ${user.id}:`, userError)
        await logPipeline(supabase, user.id, 'generation', 'error', 
          userError instanceof Error ? userError.message : 'Unknown error')
        results.push({
          userId: user.id,
          status: 'error',
          error: userError instanceof Error ? userError.message : 'Unknown',
        })
      }
    }
    
    console.log(`[Auto-Gen] Completed: ${results.length} users processed`)
    return { processed: users.length, results }
    
  } catch (error) {
    console.error('[Auto-Gen] Fatal error:', error)
    return {
      processed: 0,
      results: [{
        userId: 'system',
        status: 'error',
        error: error instanceof Error ? error.message : 'Unknown error',
      }],
    }
  }
}
